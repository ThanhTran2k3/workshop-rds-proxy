[
{
	"uri": "http://localhost:1313/workshop-rds-proxy/",
	"title": "Amazon RDS Proxy",
	"tags": [],
	"description": "",
	"content": "Amazon Relational Database Service Proxy (Amazon RDS Proxy) Overview of Amazon RDS Proxy Amazon Relational Database Service Proxy (Amazon RDS Proxy) is a fully managed database proxy service for Amazon RDS that helps improve performance, increase availability, and enhance scalability for applications using Amazon RDS or Aurora.\nWhat is RDS Proxy? RDS Proxy acts as an intermediary layer between applications and Amazon RDS or Aurora. RDS Proxy manages connection pooling to reduce database connection overhead and reuses existing connections to optimize resources and improve application performance.\nKey Benefits Feature Benefits Connection Pooling Reduces new connections and saves resources Automatic failover Increases application availability Lambda/Container optimization Reduces cost and latency in serverless High security Supports IAM, TLS and Secrets Manager Reduces \u0026ldquo;too many connections\u0026rdquo; errors Prevents database connection limit exceeded Security Integration RDS Proxy supports:\nIAM authentication: No need to store username/password in applications TLS encryption: End-to-end encryption from application to database Secrets Manager: Secure storage and rotation of login credentials Suitable Use Cases Serverless applications (AWS Lambda) requiring fast connections Microservices with multiple instances accessing the same DB Reducing cost and latency when connecting to database frequently Systems requiring automatic recovery during failover How It Works Application connects to RDS Proxy endpoint instead of RDS endpoint RDS Proxy checks connection pool, reuses connection if available If not available, RDS Proxy opens new connection to RDS endpoint Manages connection lifecycle and automatic failover Important Notes RDS Proxy does not replace RDS or Aurora but serves as an intermediate connection layer. You need to enable IAM role for Lambda/EC2 to connect to proxy. Use with Multi-AZ RDS to increase availability for failover scenarios. RDS Proxy must be in the same VPC as RDS. If you are building a system that requires high availability and good performance when accessing databases, RDS Proxy is a service worth considering.\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/3.-configuration/3.1-create-application-load-balancer/",
	"title": "Create Application Load Balancer",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Open EC2 Service Search and select the EC2 service\n2. Create Target Groups Go to EC2 \u0026gt; select Target groups\nClick Create target group\nEnter the following information:\nIn the Specify group details step: Under Basic configuration: Basic configuration \u0026gt; select IP addresses Target group name: MyApp-TG Protocol: HTTP, Port: 8080 IP address type \u0026gt; select IPv4 VPC select MyAPP-VPC Protocol version \u0026gt; select HTTP1 Click Next to continue In the Register targets step: Click Create target group to proceed 3. Create Application Load Balancer Go to EC2 \u0026gt; select Load Balancers\nClick Create load balancer\nUnder Load balancer types, select Application Load Balancer\nEnter the following information:\nUnder Basic configuration: Load balancer name: MyApp-ALB Scheme \u0026gt; select Internet-facing Load balancer IP address type \u0026gt; select **IPv4` Under Network mapping: VPC \u0026gt; select MyApp-VPC Availability Zones and subnets: Select ap-southeast-1a (apse1-az1) \u0026gt; select PublicSubnet1 Select ap-southeast-1b (apse1-az1) \u0026gt; select PublicSubnet2 Under Security groups: Security groups \u0026gt; select SG-ALB Under Listeners and routing: Default action \u0026gt; select MyApp-TG Click Create load balancer to complete\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/2.-preparation/1.-create-vpc--subnet/",
	"title": "Create VPC and Subnet",
	"tags": [],
	"description": "",
	"content": "Amazon Virtual Private Cloud (VPC) Amazon Virtual Private Cloud (Amazon VPC) allows you to launch AWS resources in a logically isolated network that you define. It acts like a virtual data center in the cloud.\nüõ†Ô∏è Steps to Implement 1Ô∏è. Access AWS Management Console Go to AWS Management Console\nSearch and select the VPC service\n2Ô∏è. Create a New VPC Go to VPC Dashboard \u0026gt; select Your VPCs\nClick Create VPC\nChoose VPC only\nFill in the details:\nName tag: MyApp-VPC IPv4 CIDR block: 10.0.0.0/16 Tenancy: Default Click Create VPC\nüìå Explanation:\nCIDR 10.0.0.0/16 allows you to divide into multiple subnets. Tenancy: Default helps reduce costs and allows all EC2 instance types. 3Ô∏è. Enable DNS Settings for the VPC Go back to Your VPCs\nSelect the VPC you just created \u0026gt; click Actions \u0026gt; Edit VPC settings\nEnable:\n‚úÖ DNS hostnames ‚úÖ DNS resolution Click Save 4Ô∏è. Create Subnets 4.1 Create PublicSubnet1 Go to VPC Dashboard \u0026gt; select Subnets Click Create subnet Fill in the details: VPC ID, select MyApp-VPC Subnet name: PublicSubnet1 Availability Zone: Choose any (e.g., ap-southeast-1a) IPv4 CIDR block: 10.0.1.0/24 Click Create subnet 4.2 Create PrivateSubnet1 Go to VPC Dashboard \u0026gt; select Subnets Click Create subnet Fill in the details: VPC ID, select MyApp-VPC Subnet name: PrivateSubnet1 Availability Zone: Choose any (e.g., ap-southeast-1b) IPv4 CIDR block: 10.0.2.0/24 Click Create subnet 4.3 Create PrivateSubnet2 Go to VPC Dashboard \u0026gt; select Subnets Click Create subnet Fill in the details: VPC ID, select MyApp-VPC Subnet name: PrivateSubnet2 Availability Zone: Choose any (e.g., ap-southeast-1b) IPv4 CIDR block: 10.0.3.0/24 Click Create subnet ‚úÖ Expected Result A VPC named MyApp-VPC with CIDR 10.0.0.0/16 is created\nA public subnet PublicSubnet1 created for ALB and NAT Gateway\nTwo private subnet PrivateSubnet1 created for ECS, RDS, RDS Proxy\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/1.-introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "1. Overview Amazon RDS Proxy is a fully managed database proxy service by AWS, designed to optimize connections to Amazon RDS and Amazon Aurora. This service helps applications:\nImprove database access performance. Optimize connection reuse (connection pooling). Reduce latency in serverless environments like AWS Lambda. Increase availability and failover resilience. 2. How It Works RDS Proxy operates as an intelligent intermediary layer between applications and databases:\nConnection Pooling: RDS Proxy maintains a pool of connections to the backend database. When applications request access, RDS Proxy will reuse existing connections if available, or open new ones if needed. RDS Proxy manages connection lifetime, failover, and opening/closing connections based on system status. 3. Key Features Feature Description üîÅ Connection pooling Reduces concurrent database connections, avoiding connection limits ‚ö° Lambda/Container optimization Reduces latency when connecting to databases in serverless environments üîê IAM \u0026amp; TLS integration Strong security with IAM, Secrets Manager, and TLS encryption üõ°Ô∏è Automatic failover Supports automatic database backend switching during failures üìä Monitoring integration Integrates with CloudWatch for performance monitoring 4. Pricing and Regional Availability \u0026amp; Versions üí∞ Pricing Amazon RDS Proxy pricing is based on:\nNumber of vCPUs used by the proxy Runtime of the proxy (per hour) No additional charges based on number of connections or requests You still pay standard charges for Amazon RDS or Aurora üìò View detailed pricing\n5. Quotas and Limits for RDS Proxy Item Default Number of Proxies per account 20 Target groups per Proxy 20 Database instances per Proxy 1 Endpoints per Proxy 1 Connection acquisition timeout 120 seconds (adjustable) Concurrent connections supported Thousands (auto scale) You can request limit increases through AWS Support if needed.\nAdditional Limitations for RDS for MariaDB Limitations when using Amazon RDS Proxy with RDS for MariaDB:\nProxy only listens on port 3306, but still connects to the database using the configured port. ‚ùå Does not support self-managed MariaDB on EC2. ‚ùå Does not work if read_only = 1 in the database parameter group. ‚ùå Does not support MariaDB compression (--compress, -C). ‚ùå Does not support auth_ed25519 authentication plugin. ‚ùå Does not support TLS 1.3. ‚ö†Ô∏è GET DIAGNOSTICS may return incorrect results if RDS Proxy reuses connections. ‚ùå Does not support caching_sha2_password (via ClientPasswordAuthType). ‚ö†Ô∏è Should not use sql_auto_is_null = true in proxy initialization queries ‚Äî may cause application errors. Additional Limitations for RDS for Microsoft SQL Server Limitations when using RDS Proxy with RDS for SQL Server:\n‚ö†Ô∏è Number of Secrets in AWS Secrets Manager may be high if SQL Server uses case-sensitive collation. ‚ùå Does not support connections using Active Directory. ‚ùå IAM authentication does not work with clients that don\u0026rsquo;t support token attributes. ‚ö†Ô∏è System variables like @@IDENTITY, @@ROWCOUNT, SCOPE_IDENTITY() may return incorrect values if not retrieved within the same statement session. ‚ùå If using MARS (Multiple Active Result Sets), proxy will not execute initialization queries. ‚ùå Does not support SQL Server 2014 and SQL Server 2022 versions. ‚ùå Does not support clients that cannot handle multiple TLS messages in one record. Additional Limitations for RDS for MySQL Limitations when using Amazon RDS Proxy with RDS for MySQL:\nProxy only listens on port 3306. ‚ùå Does not support self-managed MySQL on EC2. ‚ùå Does not work if read_only = 1 in the database parameter group. ‚ùå Does not support MySQL compression (--compress, -C). ‚ùå Does not support MySQL dual password. ‚ùå Does not support clients that cannot handle multiple responses in one TLS record. ‚ö†Ô∏è GET DIAGNOSTICS may return incorrect results when reusing connections. ‚ö†Ô∏è Some statements like SET LOCAL may change session state without causing pinning. ‚ùå ROW_COUNT() does not work correctly with multi-statement queries. ‚ö†Ô∏è With MySQL 8.4 C driver, mysql_stmt_bind_named_param() may create error packets if parameter count exceeds placeholders. ‚ö†Ô∏è caching_sha2_password requires TLS and may have issues with Go driver (go-sql). ‚ö†Ô∏è Should not use sql_auto_is_null = true in initialization queries. Additional Limitations for RDS for PostgreSQL Limitations when using Amazon RDS Proxy with RDS for PostgreSQL:\nProxy only listens on port 5432. ‚ùå Does not support CancelRequest command from client (like Ctrl+C in psql). ‚ö†Ô∏è lastval results may be inaccurate ‚Äî should use INSERT ... RETURNING. ‚ùå Does not support streaming replication. ‚ö†Ô∏è scram_iterations defaults to 4096 when client auth with proxy (PostgreSQL 16). ‚ö†Ô∏è Requires a default database. ‚ö†Ô∏è If using ALTER ROLE ... SET ROLE, need to set SET ROLE again in initialization query to avoid pinning errors. ‚ùå Does not support session pinning filters for PostgreSQL. ‚úÖ Note: Limitations may change over time. Refer to the official Amazon RDS Proxy documentation for updates.\n6. RDS Proxy Concepts and Terminology Term Description Proxy endpoint Address that applications use instead of the original database endpoint Connection pool Group of pre-opened connections to serve multiple clients Target group Group of database instances associated with a Proxy IAM Role Role assigned to grant Proxy access from Lambda or EC2 Secrets Manager Service for securely storing database login credentials 7. Security Amazon RDS Proxy integrates multiple security layers:\nIAM Authentication: Applications authenticate using IAM roles, no need for hard-coded passwords. TLS Encryption: Encrypts entire transmission path from client ‚Üí proxy ‚Üí backend database. Secrets Manager: Manages, rotates, and protects login credentials. VPC Integration: Operates within Virtual Private Cloud (VPC), limiting access to internal networks. 8. Notes RDS Proxy does not replace the database, but serves as an intermediary layer for performance and security enhancement. Proxy must be in the same VPC as RDS or Aurora. Does not support all database versions or configurations (Oracle, SQL Server). Works best with applications using short-term, high-concurrency connections like Lambda or microservices. Should not use RDS Proxy if applications have few connections and long-term persistent connections. 9. Integration with Other AWS Services Amazon RDS Proxy works efficiently when integrated with other AWS services:\nService Primary Integration Role AWS Lambda Short-term, high-scale connections ‚Äî reduces cold start and timeout when accessing database Amazon ECS / EKS Supports stable and secure database access via proxy from containers Amazon CloudWatch Monitors metrics like ConnectionCount, CurrentClientConnections AWS Secrets Manager Automatically rotates and protects authentication credentials AWS IAM IAM role-based authentication instead of hard-coded passwords 10. Monitoring Metrics (CloudWatch Metrics) RDS Proxy provides several important CloudWatch metrics for monitoring and diagnosing performance:\nMetric Meaning DatabaseConnections Number of connections to backend database currently in use ClientConnections Number of client connections to proxy CurrentSessionPercent Percentage of sessions in use out of total possible DatabaseConnectionBorrowTimeouts Number of times clients failed to acquire connection within timeout ActiveConnections Total number of actively used connections üëâ You can set up automatic alerts based on these metrics using Amazon CloudWatch Alarms for proactive monitoring and timely response to performance issues.\n11. Best Practices for Using RDS Proxy To achieve maximum performance and ensure stability when using Amazon RDS Proxy, you should apply the following practices:\n‚úÖ Design applications to use short-term connections: Avoid holding database connections unnecessarily long. ‚úÖ Use IAM or Secrets Manager: Avoid hard-coding credentials in source code. ‚úÖ Regularly monitor CloudWatch metrics: To detect issues in a timely manner. ‚úÖ Optimize database parameter configuration in Parameter Group: such as connection timeout, autocommit,\u0026hellip; ‚úÖ Configure initialization queries clearly to ensure each connection starts with the desired state. üí° Good design of initialization queries and connection state control helps reduce connection pinning and improves connection reuse efficiency.\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/2.-preparation/2.-cretae-internet-gateway--nat-gateway/",
	"title": "Configure Internet Gateway &amp; NAT Gateway",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Create an Internet Gateway (IGW) Go to VPC Dashboard \u0026gt; select Internet Gateways\nClick Create internet gateway\nFill in the details:\nName tag: MyApp-IGW Click Create internet gateway\nAfter creation, select MyApp-IGW \u0026gt; click Actions \u0026gt; select Attach to VPC\nChoose MyApp-VPC \u0026gt; click Attach internet gateway\nüìå Explanation:\nThe Internet Gateway allows public subnets to access the Internet. 2. Create a NAT Gateway Go to VPC Dashboard \u0026gt; select NAT Gateways\nClick Create NAT Gateway\nFill in the details:\nName: MyApp-NAT Subnet: select PublicSubnet1 Elastic IP allocation ID: select Allocate Elastic IP Click Create NAT Gateway\nüìå Explanation:\nThe NAT Gateway allows private subnets to access the Internet (e.g., for system updates, downloading packages). "
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/3.-configuration/3.2-deploying-application-on-ecs/",
	"title": "Deploying Application on ECS",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Open Elastic Container Service Search and select the Elastic Container Service\n2. Create Task Definition Preparation:\nGo to AWS Aurora and RDS Select Databases \u0026gt; Open MyApp-RDS Note the Endpoint value for DB_HOST Go to AWS Aurora and RDS\nSelect Proxies \u0026gt; Open MyApp-RDS-Proxy Note the Proxy endpoints for DB_PROXY_HOST Go to AWS Secrets Manager\nSelect MyAPP-Secret Note the Secret ARN value for DB_USER and DB_PASS Go to JWT Secret Key Generator Click Generated Key Note the Generated Secret Key value for JWT_SECRET Go to Google Cloud Console Note the Client ID for GOOGLE_CLIENT_ID Note the Client secret for GOOGLE_CLIENT_SECRET Tutorial video: Go to Cloudinary Console Note the Cloud name for CLOUD_NAME Note the API Key for CLOUD_API_KEY Note the API Secret for CLOUD_API_SECRET Tutorial video: Go to Amazon Elastic Container Service \u0026gt; select Task definitions Click Create new task definition Enter information:\nTask definition configuration section: Task definition family: MyApp-Task Infrastructure requirements section: Launch type \u0026gt; select AWS Fargate CPU \u0026gt; select 1 vCPU Memory \u0026gt; select 2 GB Task role \u0026gt; select ecsTaskExecutionRole Container section: Container - 1: Name: api_gateway Image URI: thanhtran2k3it/api_gateway:latest Container port: 8080 Environment variables: AUTH_API: http://localhost:8081 USER_API: http://localhost:8082 FILE_API: http://localhost:8083 DB_HOST: myapp-rds.c3aaekemgmo1.ap-southeast-1.rds.amazonaws.com:3306 DB_USER: arn:aws:secretsmanager:...:username:: DB_PASS: arn:aws:secretsmanager:...:password:: In Logging - optional \u0026gt; select Use log collection Click Add container to add\nContainer - 2:\nName: auth_service Image URI: thanhtran2k3it/auth_service:latest Container port: 8081 Environment variables: DB_PROXY_HOST, DB_USER, DB_PASS, JWT_SECRET, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, HOST_NAME In Startup dependency ordering \u0026gt; Add dependency on api_gateway Add Container - 3: user_service, port 8082, similar setup Add Container - 4: file_service, port 8083, with Cloudinary ENV vars Click Create\n3. Create ECS Cluster Go to ECS \u0026gt; Clusters \u0026gt; Create cluster\nCluster config:\nName: Myapp-Cluster Use AWS Fargate (serverless) Click Create\n4. Create Service Go to ECS \u0026gt; Clusters \u0026gt; Select Myapp-Cluster\nOpen Services tab \u0026gt; Create\nService config:\nTask definition: MyApp-Task Name: MyApp-Service Launch type: FARGATE, version: LATEST Networking: VPC: MyApp-VPC, Subnets: Private1 \u0026amp; Private2, SG: SG-ECS, Public IP: Turn on Load balancing: Enable it, type: ALB Target: api_gateway 8080:8080, ALB: MyApp-ALB, Listener: HTTP:80, TG: MyApp-TG Click Create\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/2.-preparation/",
	"title": "Preparation",
	"tags": [],
	"description": "",
	"content": "AWS Environment Setup This document guides the necessary steps to set up the AWS infrastructure before deploying services like ECS, RDS, and RDS Proxy.\nContents 1. Create VPC and Subnet 2. Create Internet Gateway and NAT Gateway 3. Create Route Tables 4. Create Security Groups 5. Create RDS Instance 6. Use AWS Secrets Manager 7. Assign IAM Role for ECS and RDS Proxy 8. Create RDS Proxy 1. Create VPC and Subnet Step 1: Create a new VPC with CIDR 10.0.0.0/16. Step 2: Create four subnets: PublicSubnet1: used for ALB and NAT Gateway (e.g., 10.0.1.0/24) PublicSubnet2: used for ALB and NAT Gateway (e.g., 10.0.4.0/24) PrivateSubnet1: used for ECS, RDS, and RDS Proxy (e.g., 10.0.2.0/24) PrivateSubnet2: used for ECS, RDS, and RDS Proxy (e.g., 10.0.3.0/24) 2. Create Internet Gateway and NAT Gateway Step 1: Create and attach an Internet Gateway (IGW) to the VPC. Step 2: Create a NAT Gateway in PublicSubnet1 and assign an Elastic IP. Step 3: Configure the route tables: Public subnet ‚Üí IGW for direct Internet access. Private subnet ‚Üí NAT Gateway for indirect Internet access. 3. Create Route Tables Create two route tables: MyApp-Public-RT: assign to public subnets and route to the Internet via IGW. MyApp-Private-RT: assign to private subnets and route to the NAT Gateway. 4. Create Security Groups Step 1: Create SG-ALB to allow HTTP/HTTPS access (port 80/443) from the Internet. Step 2: Create SG-ECS to allow ALB to access ECS (port 8080). Step 3: Create SG-RDSProxy to allow ECS to access RDS Proxy (port 3306). Step 4: Create SG-RDS to allow ECS and Proxy to access the Database. 5. Create RDS Instance Step 1: Create a DB Subnet Group. Step 2: Deploy the database in PrivateSubnet1 and PrivateSubnet2. Step 3: Choose MySQL as the database engine. Step 4: Attach the SG-RDS Security Group. 6. Use Secrets Manager Step 1: Create a secret in AWS Secrets Manager to store DB login credentials in JSON format. Step 2: Record the secret ARN to use in ECS Task configuration. 7. Assign IAM Role Step 1: Create IAM roles: ecsTaskExecutionRole, codeDeployServiceRole, and rdsProxyServiceRole Step 2: Attach policies to allow: Access to Secrets Manager Connection to RDS Database Write logs to CloudWatch 8. Create RDS Proxy Step 1: Create an RDS Proxy to connect ECS to RDS. Step 2: Select the created RDS instance. Step 3: Assign the rdsProxyServiceRole IAM role to the RDS Proxy. Step 4: Select subnet group PrivateSubnet1 and PrivateSubnet2. Step 5: Assign the SG-RDSProxy Security Group. Make sure all the components above are properly configured before proceeding with ECS deployment and establishing connection to RDS Proxy.\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/2.-preparation/3.create-route-tables/",
	"title": "Create Route Table",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Create Route Table for Public Subnet Go to VPC Dashboard \u0026gt; select Route Tables\nClick Create route table\nFill in the details:\nName tag: MyApp-Public-RT VPC: select MyApp-VPC Click Create route table\nSelect the route table you just created \u0026gt; Routes tab \u0026gt; click Edit routes\nClick Add route Destination: 0.0.0.0/0 Target: choose Internet Gateway (MyApp-IGW) Click Save changes Go to the Subnet associations tab \u0026gt; click Edit subnet associations\nCheck PublicSubnet1 Click Save associations 2. Create Route Table for Private Subnet Click Create route table\nFill in the details:\nName tag: MyApp-Private-RT VPC: select MyApp-VPC Click Create route table\nSelect the route table you just created \u0026gt; Routes tab \u0026gt; Edit routes\nClick Add route Destination: 0.0.0.0/0 Target: choose NAT Gateway (MyApp-NAT) Click Save changes Go to the Subnet associations tab \u0026gt; click Edit subnet associations\nCheck PrivateSubnet1 Click Save associations "
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/3.-configuration/3.3-deploying-a-static-website/",
	"title": "Deploying a static Website",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Preparation Go to EC2\nSelect Load Balancers \u0026gt; Open MyApp-ALB Note the value of Load balancer ARN Visit Git\nDownload and install Git\nAfter installation, open Git Bash or Command Prompt.\ngit clone https://github.com/ThanhTran2k3/workshop_rds_proxy_FE.git cd workshop_rds_proxy_FE Open the config.json file\nnotepad config.json Update the API_URL value: use the Load balancer ARN\nSave the config.json file.\n2. Open S3 Service Search for and select S3\n3. Create a Bucket Go to Amazon S3 \u0026gt; select General purpose buckets\nClick Create bucket\nEnter the following details:\nUnder General configuration: Bucket name: myapp-s3-3291 ‚ö†Ô∏è Note: The bucket name must be unique across AWS and must not contain uppercase letters. Under Block Public Access settings for this bucket: Uncheck Block all public access Check I acknowledge that the current settings might result in this bucket and the objects within becoming public. Click Create bucket\n4. Upload Files Go to Amazon S3 \u0026gt; select General purpose buckets\nOpen myapp-s3-3291\nClick Upload\nAdd files from the workshop_rds_proxy_FE folder\nClick Upload\n5. Configure Bucket for Website Hosting Open myapp-s3-3291\nGo to the Properties tab\nUnder Static website hosting \u0026gt; click Edit\nEnter the following details: Static website hosting \u0026gt; select Enable Hosting type \u0026gt; select Host a static website Index document: index.html Error document: index.html Click Save changes 6. Grant Public Access to the Website Open myapp-s3-3291\nGo to the Permissions tab\nUnder Bucket policy \u0026gt; click Edit\nPaste the following JSON into the Policy\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::your-bucket-name/*\u0026#34; } ] } Click Save changes\nGo to the Properties tab\nPaste the Bucket website endpoint into a browser to verify\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/3.-configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": "Table of Contents 1. Create Application Load Balancer 2. Deploy application on ECS 3. Deploy static website 4. Configure CloudFront 1. Create Application Load Balancer Step 1: Create a Target Group. Step 2: Create an ALB to distribute traffic to ECS containers. Step 3: Select PublicSubnet1 and PublicSubnet2. Step 4: Attach the SG-ALB Security Group. 2. Deploy application on ECS Step 1: Create an ECS Cluster. Step 2: Create a Task Definition, specifying container, port, CPU, and memory. Step 3: Create a Service, choose FARGATE launch type, and assign the Task Definition. Step 4: Attach the Application Load Balancer to the Service to handle traffic. 3. Deploy static website Step 1: Go to the S3 service and create a new bucket. Step 2: Upload the static source files (HTML/CSS/JS) to the S3 bucket. Step 3: Enable static website hosting for the bucket. Step 4: Configure the Bucket Policy to make files public if needed. 4. Configure CloudFront Step 1: Go to the CloudFront service and create a new Distribution. Step 2: Choose origins as S3 and ALB. Step 3: Configure custom error responses. Step 4: Copy the CloudFront domain name to use as the main website URL. "
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/4.-clean-up-resources/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": "Resource Cleanup ‚ÑπÔ∏è Note: Properly cleaning up AWS resources after completing the lab is essential to avoid unexpected charges to your AWS account. Follow the steps below to ensure all resources have been terminated and deleted.\nüõ†Ô∏è Steps to Implement 1. Clean up CloudFront Go to AWS CloudFront\nSelect Distributions \u0026gt; choose the created distribution Click Disable, this action will take a few minutes. Once disabled, click Delete Go to Origin access \u0026gt; select the generated Origin access controls Click Delete 2. Clean up S3 bucket Go to AWS S3\nSelect General purpose buckets \u0026gt; open the created bucket Select all files inside the bucket Click Delete To confirm deletion, type permanently delete in the text input field.: permanently delete Click Delete objects Return to General purpose buckets \u0026gt; select the created bucket Click Delete To confirm deletion, enter the name of the bucket in the text input field.: your-bucket-name Click Delete bucket 3. Clean up ECS Go to AWS ECS\nSelect Clusters \u0026gt; open Myapp-Cluster Under the Services tab Select MyApp-Service \u0026gt; click Delete service Choose Force delete To confirm deletion, enter delete in the text input field.: delete Click Delete Click Delete cluster Enter the phrase \u0026ldquo;delete Myapp-Cluster\u0026rdquo; to confirm deletion.: delete Myapp-Cluster Click Delete, this will take a few minutes. Go to Task definitions \u0026gt; open MyApp-Task Select all Task definition: revision Click Actions \u0026gt; choose Deregister 4. Clean up Application Load Balancer and Target Groups Go to EC2\nSelect Load Balancers \u0026gt; choose MyApp-ALB Click Actions \u0026gt; choose Delete load balancer Type confirm to agree.: confirm Click Delete Select Target Groups \u0026gt; choose MyApp-TG Click Actions \u0026gt; choose Delete 5. Clean up RDS Proxy Go to AWS RDS\nSelect Proxies \u0026gt; choose MyApp-RDS-Proxy Click Actions \u0026gt; choose Delete To confirm deletion, type delete me into the field: delete me Click Delete, this may take a few minutes. 6. Clean up IAM Role Go to IAM\nSelect Roles \u0026gt; choose codeDeployServiceRole, ecsTaskExecutionRole, and rdsProxyServiceRole Click Delete To confirm deletion, enter delete in the text input field.: delete Click Delete Select Policies \u0026gt; choose rdsProxyAccessPolicy Click Delete To confirm deletion, enter the policy name in the text input field.: rdsProxyAccessPolicy Click Delete Select ecsTaskRDSAccessPolicy Click Delete To confirm deletion, enter the policy name in the text input field.: ecsTaskRDSAccessPolicy Click Delete 7. Clean up Secrets Manager Go to AWS Secrets Manager\nOpen MyAPP-Secret Click Actions \u0026gt; choose Delete secret Click Schedule deletion 8. Clean up RDS Instance Go to AWS RDS\nSelect Databases \u0026gt; choose MyApp-RDS Click Actions \u0026gt; choose Delete To confirm deletion, type delete me into the field.: delete me Click Delete, this will take a few minutes. Select Subnet groups \u0026gt; choose MyApp-RDSSG Click Delete 9. Clean up Security Groups Go to AWS VPC\nSelect Security groups \u0026gt; choose SG-ALB, SG-ECS, SG-RDSProxy, and SG-RDS Click Actions \u0026gt; choose Delete security group To confirm deletion, enter delete below.: delete Click Delete 10. Clean up Internet Gateway and NAT Gateway Go to AWS VPC\nSelect NAT gateways \u0026gt; choose MyApp-NAT Click Actions \u0026gt; choose Delete NAT gateway To confirm deletion, type delete in the field:: delete Click Delete, this will take a few minutes. Select Elastic IPs \u0026gt; choose the generated Elastic IP Click Actions \u0026gt; choose Release Elastic IP addresses Click Release Select Internet gateways \u0026gt; choose MyApp-IGW Click Actions \u0026gt; choose Detach from VPC Click Detach internet gateway Select MyApp-IGW Click Actions \u0026gt; choose Delete internet gateway To confirm deletion, type delete in the field:: delete Click Delete internet gateway 11. Clean up VPC and Subnet Go to AWS VPC\nSelect Subnets \u0026gt; choose PublicSubnet1, PublicSubnet2, PrivateSubnet1, and PrivateSubnet2 Click Actions \u0026gt; choose Delete subnet To confirm deletion, type delete in the field: delete\nClick Delete\nSelect Your VPCs \u0026gt; choose MyApp-VPC\nClick Actions \u0026gt; choose Delete VPC\nTo confirm deletion, type delete in the field:: delete Click Delete "
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/3.-configuration/3.4-configure-cloudfront/",
	"title": "Configure CloudFront",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Block All Public Access to S3 Open myapp-s3-3291\nGo to the Permissions tab\nIn the Block public access (bucket settings) section \u0026gt; click Edit\nSelect Block all public access\nClick Save changes\n2. Open Amazon CloudFront Service Search for and select CloudFront\n3. Create a Distribution Go to Amazon CloudFront \u0026gt; choose Distributions\nClick Create distribution\nEnter the following details:\nGet started step: Distribution name: MyApp-Distribution Click Next to continue Configure distribution step: Origin type \u0026gt; select Amazon S3 S3 origin \u0026gt; click Browse S3, choose myapp-s3-3291 Click Next to continue Enable security step: Web Application Firewall (WAF) \u0026gt; choose Do not enable security protections Click Next to continue Review and create step: Click Create distribution to create 4. Update Distribution Go to Amazon CloudFront \u0026gt; choose Distributions\nOpen the newly created distribution\nGo to the Origins tab:\nSelect http://myapp-s3-3291.s3-website-ap-southeast-1.amazonaws.com Click Edit In Settings: Origin access \u0026gt; choose Origin access control settings (recommended) Click Create new OAC Click Create Click Save changes Go to the General tab:\nClick Edit In Settings: Default root object - optional: index.html Click Save changes Go to the Error pages tab:\nClick Create custom error response In Error response: HTTP error code \u0026gt; choose 403: Forbidden Customize error response \u0026gt; choose Yes Response page path: /index.html HTTP Response code \u0026gt; choose 200: OK Click Create custom error response 5. Update S3 Bucket Policy Go to Amazon S3 \u0026gt; choose General purpose buckets\nOpen myapp-s3-3291\nGo to the Permissions tab\nIn the Bucket policy section \u0026gt; click Edit\nPaste the following JSON into Policy:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2008-10-17\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;PolicyForCloudFrontPrivateContent\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;AllowCloudFrontServicePrincipal\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;cloudfront.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::your-bucket-name/*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:aws:cloudfront::329178086719:distribution/your-distributions-ID\u0026#34; } } } ] } Click Save changes\n6. Configure AWS ALB Access via CloudFront Go to Amazon CloudFront \u0026gt; select Distributions\nOpen the newly created distribution\nGo to the Origins tab:\nClick Create origin In Settings Origin domain \u0026gt; select MyApp-ALB Protocol \u0026gt; select HTTP only HTTP port: 80 Click Create origin to proceed Go to the Behaviors tab:\nClick Create behavior In Settings Path pattern \u0026gt; choose /api/* Origin and origin groups \u0026gt; select MyApp-ALB Viewer protocol policy \u0026gt; choose Redirect HTTP to HTTPS Allowed HTTP methods \u0026gt; choose GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE Cache policy \u0026gt; choose CachingDisabled Origin request policy - optional \u0026gt; choose AllViewerExceptHostHeader Click Create behavior to proceed 7. Update config.json File Preparation:\nGo to AWS Cloud Front Select Distributions \u0026gt; Open the newly created distribution Note down the Distribution domain name Open Amazon S3 \u0026gt; select General purpose buckets\nOpen myapp-s3-3291\nIn the Objects tab\nSelect the config.json file \u0026gt; click Download Open the downloaded config.json file\nReplace the value of API_URL with the noted Distribution domain name\nSave the file and re-upload it to S3\nIn the Objects tab:\nClick Upload Select the modified config.json file Click Upload to upload 8. Verify the Website Paste the Distribution domain name into the browser to verify\nCheck some features that make requests to the backend on ECS\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/2.-preparation/4.-create-security-groups/",
	"title": "Create Security Groups",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Create SG-ALB Go to VPC Dashboard \u0026gt; select Security Groups.\nClick Create Security Group.\nFill in the details:\nSecurity group name: SG-ALB Description: Allow HTTP/HTTPS from Internet VPC: Select MyApp-VPC In the Inbound rules section, click Add rule:\nType: HTTP, Port: 80, Source: 0.0.0.0/0 Type: HTTPS, Port: 443, Source: 0.0.0.0/0 Click Create Security Group.\n2. Create SG-ECS Go to VPC Dashboard \u0026gt; select Security Groups.\nClick Create Security Group.\nFill in the details:\nSecurity group name: SG-ECS Description: Allow traffic from ALB to ECS VPC: Select MyApp-VPC In the Inbound rules section, click Add rule:\nType: Custom TCP, Port: 8080, Source: SG-ALB Click Create Security Group.\n3. Create SG-RDSProxy Go to VPC Dashboard \u0026gt; select Security Groups.\nClick Create Security Group.\nFill in the details:\nSecurity group name: SG-RDSProxy\nDescription: Allow ECS to access RDS Proxy\nVPC: Select MyApp-VPC\nIn the Inbound rules section, click Add rule:\nType: MYSQL/Aurora, Port: 3306, Source: SG-ECS Click Create Security Group.\n4. Create SG-RDS Go to VPC Dashboard \u0026gt; select Security Groups. Click Create Security Group.\nFill in the details:\nSecurity group name: SG-RDS Description: Allow RDS Proxy to access DB VPC: Select MyApp-VPC Under Inbound rules, click Add rule:\nType: MYSQL/Aurora, Port: 3306, Source: SG-RDSProxy Click Create Security Group.\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/2.-preparation/5.-create-rds-instance/",
	"title": "Create RDS Database Instance",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Open the RDS Service Search and select Aurora and RDS service\n2. Create DB Subnet Group Go to Aurora and RDS \u0026gt; select Subnet groups\nClick Create DB subnet group\nFill in the details:\nName: MyApp-RDSSG Description: Subnet group for RDS MySQL VPC \u0026gt; select MyApp-VPC Availability Zone \u0026gt; select ap-southeast-1b and ap-southeast-1c Subnets \u0026gt; select PrivateSubnet1 and PrivateSubnet2 Click Create\n3. Create Database Go to Aurora and RDS \u0026gt; select Databases\nClick Create database\nFill in the details:\nChoose a database creation method \u0026gt; select Standard create Engine options: Engine type \u0026gt; select MySQL Templates \u0026gt; select Dev/Test Availability and durability: Deployment options \u0026gt; select Multi-AZ DB instance deployment (2 instances) Settings: DB instance identifier: MyApp-RDS Master username: admin Credentials management \u0026gt; select Self managed Set your own Master password Instance configuration: DB instance class \u0026gt; select Burstable classes (includes t classes) \u0026gt; choose db.t3.micro Storage: Storage type \u0026gt; select General Purpose SSD (gp2) Allocated storage: 20 Connectivity: Compute resource \u0026gt; select Don‚Äôt connect to an EC2 compute resource Virtual private cloud (VPC) \u0026gt; select MyApp-VPC DB subnet group \u0026gt; select MyApp-RDSSG Existing VPC security groups \u0026gt; select SG-RDS Click Create database\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/2.-preparation/6.-create-secrets-manager/",
	"title": "Create Secrets Manager",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Follow 1. Open Secrets Manager Service Search and select Secrets Manager\n2. Create a Secret Go to AWS Secrets Manager \u0026gt; select Secrets\nClick Store a new secret\nIn the Choose secret type step:\nSecret type \u0026gt; select Credentials for RDS database Under Credentials: User name: admin Password: your-password ‚úÖ Or select Other type of secrets and manually enter JSON data:\n{ \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;your-password\u0026#34; } Under Database, select MyApp-RDS\nClick Next to continue\nIn the Configure secret step:\nSecret name: MyAPP-Secret Description: MySQL database credentials Click Next to continue In the Configure rotation step:\nClick Next to continue In the Review step:\nClick Store to create the secret "
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/2.-preparation/7.-create-iam-role/",
	"title": "Create IAM Role",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Create Policies 1.1. Create Policy for ECS Task Search and select the IAM service.\nGo to Identity and Access Management (IAM) \u0026gt; select Policies\nClick Create policy.\nIn the Specify permissions step:\nSwitch to the JSON tab and paste the following content: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;secretsmanager:GetSecretValue\u0026#34;, \u0026#34;rds-db:connect\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Click Next to continue.\nIn the Review and create step:\nEnter: Policy name: ecsTaskRDSAccessPolicy Click Create policy.\n1.2. Create Policy for RDS Proxy Go to Identity and Access Management (IAM) \u0026gt; select Policies\nClick Create policy.\nIn the Specify permissions step:\nSwitch to the JSON tab and paste the following content: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;secretsmanager:GetSecretValue\u0026#34;, \u0026#34;secretsmanager:DescribeSecret\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Click Next to continue.\nIn the Review and create step:\nEnter: Policy name: rdsProxyAccessPolicy Click Create policy.\n2. Create Role for ECS Task Go to Identity and Access Management (IAM) \u0026gt; select Roles\nClick Create role.\nIn the Select trusted entity step:\nSelect AWS service. In Use case: Service or use case: Select Elastic Container Service Use case: Select Elastic Container Service Task Click Next. In the Add permissions step:\nSearch for ecsTaskRDSAccessPolicy \u0026gt; select it. Click Next. In the Name, review, and create step:\nRole name: ecsTaskExecutionRole Description: Secrets Manager and RDS Proxy access permissions for ECS Task Click Create role.\n3. Create CodeDeploy Role Go to Identity and Access Management (IAM) \u0026gt; select Roles\nClick Create role.\nIn the Select trusted entity step:\nSelect AWS service. In Use case: Service or use case: Select CodeDeploy Use case: Select CodeDeploy - ECS Click Next. In the Add permissions step:\nClick Next. In the Name, review, and create step:\nRole name: codeDeployServiceRole Description: Allows AWS CodeDeploy to manage deployments to Amazon ECS services, including creating and updating task definitions and ECS service configurations. Click Create role.\n4. Create Role for RDS Proxy Go to Identity and Access Management (IAM) \u0026gt; select Roles\nClick Create role.\nIn the Select trusted entity step:\nSelect AWS service. In Use case: Service or use case: Select RDS Use case: Select RDS - Add Role to Database Click Next. In the Add permissions step:\nSearch for rdsProxyAccessPolicy \u0026gt; select it. Click Next. In the Name, review, and create step:\nRole name: rdsProxyServiceRole Description: Role used by Amazon RDS Proxy to retrieve database credentials from AWS Secrets Manager Click Create role.\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/2.-preparation/8.-create-rds-proxy/",
	"title": "Create RDS Proxy",
	"tags": [],
	"description": "",
	"content": "üõ†Ô∏è Steps to Implement 1. Open the RDS Service Search and select the Aurora and RDS service\n2. Create RDS Proxy Go to Aurora and RDS \u0026gt; select Proxies\nClick Create proxy\nFill in the details:\nIn the Proxy configuration section: Engine family \u0026gt; select MariaDB and MySQL Proxy identifier: MyApp-RDS-Proxy In the Target group configuration section: Database \u0026gt; select MyApp-RDS Connection pool maximum connections: 20 In the Authentication section: Identity and access management (IAM) role \u0026gt; select rdsProxyServiceRole Secrets Manager secrets \u0026gt; select MyAPP-Secret Client authentication type \u0026gt; select MySQL Native password In the Connectivity section: Subnets \u0026gt; select PrivateSubnet1 and PrivateSubnet2 In Additional connectivity configuration: VPC security group \u0026gt; select SG-RDSProxy Click Create proxy to create it\n"
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/workshop-rds-proxy/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]